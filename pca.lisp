(in-package :heks)

(defparameter *pca-mean* (load-array-from-file "/home/tim/school/isg/pca_mean"))
(defparameter *pca-map*  (load-array-from-file "/home/tim/school/isg/pca_map"))

(defun pca-features (x)
  (destructuring-bind (m n) (array-dimensions *pca-map*)
    (iter (for j from 0 below n)
          (collecting (iter (for i from 0 below m)
                            (summing (* (aref *pca-map* i j)
                                        (- (aref x i) (aref *pca-mean* 0 i)))))
                      result-type (vector single-float)))))

(defun make-pca-evaluator (weights)
  (lambda (state moves)
    (declare (ignore moves))
    (dot-product weights (pca-features (state->vector state)))))

(defun random-search-feature-weights (opponent)
  (iter (with nsamples = 30)
        (for n from 1)
        (for weights = (map '(vector single-float)
                            (lambda (i)
                              (declare (ignore i))
                              (coerce (gaussian-random) 'single-float))
                            (iota (second (array-dimensions *pca-map*)))))
        (multiple-value-bind (mean stdev)
            (measure-performance 
             (lambda (state)
               (evaluation-decision state :evaluator (make-pca-evaluator weights) :verbose nil))
             opponent nsamples)
          (print (list weights mean stdev))
          (finding weights maximizing mean into (best-weights best-mean)))
        (when (= 0 (mod n 30))
          (fresh-line)
          (format t "best weights so far: ~A scoring ~A" best-weights best-mean))))

;; use spsa to maximize win count against opponent when using the evaluation
;; function in a 1-ply minimax search
(defun learn-feature-weights (opponent initial-weights)
  (let* ((nsteps 1000)
         (nsamples 30))
    (labels ((make-player (weights)
               (lambda (state)
                 (evaluation-decision state :evaluator (make-learned-evaluator weights) :verbose nil)))
             (performance (weights)
               (multiple-value-bind (mean stdev)
                   (measure-performance (make-player weights) opponent nsamples)
                 (print (list weights mean stdev))
                 (values mean stdev)))
             (goodness (weights)
               (+ (* 0.1 (vector-norm weights :l 1))
                  (* 0.2 (vector-norm weights :l 2))
                  (* 0.9 (- (performance weights))))))
      (multiple-value-bind (initial-mean initial-stdev) (performance initial-weights)
        (format t "initial performance ~D (±~D)~%" initial-mean initial-stdev)
        (let ((final-weights (spsa nsteps #'goodness initial-weights :c (+ initial-stdev 1e-3))))
          (multiple-value-bind (final-mean final-stdev) (performance final-weights)
            (fresh-line)
            (format t "optimized performance from ~D (±~D) to ~D (±~D)~%"
                    initial-mean initial-stdev final-mean final-stdev)
            final-weights))))))

(defun learn-feature-weights-against-mcts ()
  (let* ((k (second (array-dimensions *pca-map*)))
         (initial-weights (make-sequence '(vector single-float) k :initial-element (/ 1.0 k)))
         (mcts-player (lambda (state) (mcts-decision state :max-sample-size 100 :verbose nil))))
    (learn-feature-weights mcts-player initial-weights)))

