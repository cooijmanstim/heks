(in-package :heks)

(declaim (optimize (debug 3)))

(setq lisp-unit:*print-failures* t)
(lisp-unit:use-debugger)

(defun make-test-board-with (ijts)
  (let ((board (make-empty-board)))
    (iter (for ijt in ijts)
          (destructuring-bind (i j object owner) ijt
            (setf (board-tile board (v i j)) (make-tile :object object :owner owner))))
    board))

(define-test v
  (assert-true (v= (v 1 1) (v 1 1)))
  (assert-equality #'v= (v 0 0) (vmap (constantly 0) (v 1 2)))
  (assert-equality #'tree-equal '(1 2) (v->list (v 1 2))))

(define-test move-equal
  (assert-false (move-equal (list (v 1 1) (v 1 3))
                            (list (v 1 1) (v 1 3) (v 3 3)))))

(define-test far-modify
  (let ((l (list 1 2 3 4 5))
        (x 6))
    (iter (for k from 0 to (length l))
          (multiple-value-bind (l1 l2)
              (nbutlast* (copy-list l) k)
            (assert-equal l (append l1 l2))))
    (multiple-value-bind (l1 l2)
        (nbutlast* (copy-list l) (length l))
      (assert-equal '() l1)
      (assert-equal l l2))
    (multiple-value-bind (l3 l4)
        (nbutlast* (copy-list l) (+ 1 (length l)))
      (assert-equal '() l3)
      (assert-equal l l4))
    (let ((l (copy-list l)))
      (multiple-value-bind (l5 l6)
          (nbutlast* l 2)
        (assert-equal '(1 2 3) l5)
        (assert-equal '(4 5) l6)
        (assert-equal '(1 2 3) l)))
    (let ((l (copy-list l)))
      (far-push x l)
      (assert-equal x (lastcar l))
      (assert-equal x (far-pop l))
      (assert-equal 5 (lastcar l))))
  (let ((l (list 1 2)))
    (far-pop l)
    (assert-equal '(1) l)))

(define-test board-screen-transform
  (iter (repeat 5)
        (for ij = (vmap #'random *board-dimensions*))
        (assert-equality #'v= ij (board-position (window-position ij))))
  (assert-equalp *window-center* (window-position *board-center*)))

(define-test tile-equal
  (iter (repeat 5)
        (for ij = (vmap #'random *board-dimensions*))
        (assert-equality #'tile-equal (initial-tile ij) (initial-tile ij))))

(define-test board-equal
  (assert-equality #'board-equal (make-initial-board) (make-initial-board)))

(define-test copy-board
  (assert-equality #'board-equal (make-initial-board) (copy-board (make-initial-board))))

(define-test submove
  (assert-true (submovep (list (v 1 1))
                         (list (v 1 1) (v 1 2))))
  (assert-false (submovep (list (v 1 1))
                          (list (v 1 2) (v 1 3)))))

(define-test supermoves
  (let ((moves (list (list (v 1 1) (v 2 2))
                     (list (v 1 1) (v 2 1))
                     (list (v 1 2) (v 2 3)))))
    (assert-equality #'moveset-equal
                     (list (list (v 1 1) (v 2 2))
                           (list (v 1 1) (v 2 1)))
                     (supermoves (list (v 1 1)) moves))
    (assert-equality #'moveset-equal
                     '()
                     (supermoves (list (v 3 3)) moves))
    (assert-equality #'moveset-equal
                     (list (list (v 1 2) (v 2 3)))
                     (supermoves (list (v 1 2)) moves))))

(define-test iter-board
  (let* ((board (make-empty-board))
         (ijs (iter (for tile at ij of board)
                    (collect ij)))
         (ijs-black (iter (for tile at ij of board from *black-player*)
                          (collect ij))))
    (assert-equalp 61 (length ijs))
    (assert-equalp (v 1 1) (first ijs))
    (assert-equalp (s+v -2 *board-dimensions*) (lastcar ijs))
    (assert-equalp ijs (reverse ijs-black))))

(define-test piece-moves
  (labels ((piece-moves* (board ij)
             (with-slots (object owner) (board-tile board ij)
               (piece-moves board ij object owner))))
    (let ((board (make-test-board-with `((1 1 :man ,*white-player*)
                                         (1 2 :man ,*black-player*)
                                         (2 1 :man ,*black-player*)
                                         (2 3 :man ,*black-player*)
                                         (3 4 :man ,*white-player*)))))
      (assert-equality #'moveset-equal
                       (list (list (v 1 1) (v 2 2)))
                       (piece-moves* board (v 1 1)))
      (assert-equality #'moveset-equal
                       (list (list (v 3 4) (v 3 5))
                             (list (v 3 4) (v 4 4))
                             (list (v 3 4) (v 4 5)))
                       (piece-moves* board (v 3 4)))
      (assert-equality #'moveset-equal
                       '()
                       (piece-moves* board (v 1 2)))
      (assert-equality #'moveset-equal
                       '()
                       (piece-moves* board (v 2 1)))
      (assert-equality #'moveset-equal
                       (list (list (v 2 3) (v 1 3))
                             (list (v 2 3) (v 2 2)))
                       (piece-moves* board (v 2 3))))))

(define-test piece-captures
  (labels ((piece-captures* (board ij)
             (with-slots (object owner) (board-tile board ij)
               (piece-captures board ij object owner))))
    (let ((board (make-test-board-with `((1 1 :man ,*white-player*)
                                         (1 2 :man ,*black-player*)
                                         (2 1 :man ,*black-player*)
                                         (2 3 :man ,*black-player*)
                                         (3 4 :man ,*white-player*)))))
      (assert-equality #'moveset-equal
                       (list (list (v 1 1) (v 3 1))
                             (list (v 1 1) (v 1 3) (v 3 3)))
                       (piece-captures* board (v 1 1)))
      (assert-equality #'moveset-equal
                       '()
                       (piece-captures* board (v 3 4)))
      (assert-equality #'moveset-equal
                       '()
                       (piece-captures* board (v 1 2)))
      (assert-equality #'moveset-equal
                       '()
                       (piece-captures* board (v 2 1)))
      (assert-equality #'moveset-equal
                       (list (list (v 2 3) (v 4 5)))
                       (piece-captures* board (v 2 3))))))
  
(define-test moves
  (let ((board (make-test-board-with `((1 1 :man ,*white-player*)
                                       (1 2 :man ,*black-player*)
                                       (2 1 :man ,*black-player*)
                                       (2 3 :man ,*black-player*)
                                       (3 4 :man ,*white-player*)))))
    (assert-equality #'moveset-equal
                     (list (list (v 1 1) (v 1 3) (v 3 3)))
                     (moves (make-state :board board :player *white-player*)))
    (assert-equality #'moveset-equal
                     (list (list (v 2 3) (v 4 5)))
                     (moves (make-state :board board :player *black-player*)))))

(define-test remove-piece
  (let* ((state (make-state :board (make-test-board-with `((1 1 :man ,*white-player*))))))
    (remove-piece state (v 1 1))
    (assert-equal :empty (tile-object (board-tile (state-board state) (v 1 1))))))

(define-test displacement-direction
  (iter (repeat 2)
        (for ij = (v (random 10) (random 10)))
        (iter (for direction in *all-directions*)
              (iter (for distance from 1 to 3)
                    (multiple-value-bind (direction2 distance2)
                        (displacement-direction ij (v+v ij (s*v distance direction)))
                      (assert-equalp direction direction2)
                      (assert-equalp distance distance2)))))
  (multiple-value-bind (didj n)
      (displacement-direction (v 1 1) (v 1 2))
    (assert-equalp (v 0 1) didj)
    (assert-equalp 1 n))
  (multiple-value-bind (didj n)
      (displacement-direction (v 1 1) (v 2 2))
    (assert-equalp (v 1 1) didj)
    (assert-equalp 1 n)))

(define-test apply-move
  (let* ((test-board-designator `((1 1 :man ,*white-player*)
                                  (1 2 :man ,*black-player*)
                                  (2 1 :man ,*black-player*)
                                  (2 3 :man ,*black-player*)
                                  (3 4 :man ,*white-player*)))
         (state (make-state :board (make-test-board-with test-board-designator) :player *white-player*))
         (breadcrumbs '()))
    (push (apply-move state (list (v 1 1) (v 1 3) (v 3 3))) breadcrumbs)
    (assert-equal :empty (tile-object (board-tile (state-board state) (v 1 2))))
    (assert-equal :empty (tile-object (board-tile (state-board state) (v 2 3))))
    (unapply-move state (pop breadcrumbs))
    (assert-equal :man (tile-object (board-tile (state-board state) (v 1 2))))
    (assert-equal :man (tile-object (board-tile (state-board state) (v 2 3))))
    (toggle-player state)
    (push (apply-move state (list (v 2 3) (v 4 5))) breadcrumbs)
    (assert-equal :empty (tile-object (board-tile (state-board state) (v 3 4))))
    (unapply-move state (pop breadcrumbs))
    (assert-equal :man (tile-object (board-tile (state-board state) (v 3 4))))))

;; check hash consistency after applying and unapplying 20 moves
(define-test hash
  (iter (repeat 10)
        (let ((state (make-initial-state))
              (breadcrumbs '()))
          (iter (repeat 20)
                (for moves = (moves state))
                (push (apply-move state (random-elt moves)) breadcrumbs)
                (assert-equal (zobrist-hash state) (state-hash state)))
          (assert-false (= (state-hash state) 0))  ; duh
          (iter (for breadcrumb in breadcrumbs)
                (unapply-move state breadcrumb)
                (assert-equal (zobrist-hash state) (state-hash state))))))

(define-test state-equal
  (iter (repeat 10)
        (let* ((initial-state (make-initial-state))
               (state (copy-state initial-state))
               (breadcrumbs '()))
          (assert-equality #'state-equal state initial-state)
          (iter (repeat 10)
                (for moves = (moves state))
                (push (apply-move state (random-elt moves)) breadcrumbs)
                (assert-false (state-equal state initial-state)))
          (iter (for breadcrumb in breadcrumbs)
                (unapply-move state breadcrumb))
          (assert-equality #'state-equal state initial-state))))

;; test the evaluator machinery by comparing the non-caching #'material-evaluation to
;; the caching 'material-evaluator
(define-test material-evaluator
  (iter (repeat 10)
        (with evaluator = (make-instance 'material-evaluator))
        (let* ((state (make-initial-state)))
          (evaluation* evaluator state)
          (labels ((recur (state depth)
                     (if (= depth 0)
                         (return))
                     (let* ((moves (moves state))
                            (move (random-elt moves))
                            (breadcrumb (apply-move state move)))
                       (evaluation+ evaluator state move breadcrumb)
                       (assert-equal (material-evaluation state moves) (evaluation? evaluator state moves))
                       (recur state (1- depth))
                       (assert-equal (material-evaluation state moves) (evaluation? evaluator state moves))
                       (evaluation- evaluator state move breadcrumb)
                       (unapply-move state breadcrumb))))
            (recur state 20)))))

;; commented out because verbose
'(define-test spsa
  (labels ((f (x)
             ;; a convex quadratic function with minimum at 0
             (let ((H #2A((5 4 3)
                          (4 4 2)
                          (3 2 5))))
               (iter (for i from 0 to 2)
                     (summing (iter (for j from 0 to 2)
                                    (summing (* (aref x j) (aref H i j) (aref x i)))))))))
    (assert-float-equal 0.0 (f #(0.0 0.0 0.0)))
    (multiple-value-bind (x* xs)
        (spsa 1000 #'f (vector (random 10) (random 10) (random 10)) :c 0.1)
      (let ((fs (mapcar #'f xs)))
        (assert-true (every (lambda (x)
                              (< (abs x) 1e-3))
                            x*)
                     x* xs fs)))))

(define-test minimax-case-1
  (let ((state (read-from-string
                "#S(STATE :BOARD #2A((#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :KING :OWNER 1)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :MAN :OWNER 0)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :KING :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :EMPTY :OWNER NIL)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :MAN :OWNER 1)
                              #S(TILE :OBJECT :VOID :OWNER NIL))
                             (#S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)
                              #S(TILE :OBJECT :VOID :OWNER NIL)))
                  :PLAYER 1
                  :ENDP NIL
                  :HASH 22507219339911910660638959860807479579)"))
        (*minimax-maximum-depth* 5))
    (multiple-value-bind (move value)
        (minimax-decision (copy-state state) (make-simple-evaluator #'material-evaluation))
      (declare (ignore move))
      (assert-equal *evaluation-maximum* value))))

(define-test pmcts-uproot
  (let* ((state (make-initial-state))
         (tree (make-pmcts-tree-for-state state)))
    (dotimes (i 1000)
      (pmcts-sample tree state))
    (iter (repeat 4)
          (for move = (mcts-node-move (random-elt (mcts-node-children (pmcts-tree-current-node tree)))))
          (for breadcrumb = (apply-move state move))
          (update-pmcts-tree tree state move breadcrumb))
    (let* ((original-root (pmcts-tree-root-node tree))
           (expected-root (mcts-node-parent (pmcts-tree-current-node tree))))
      (pmcts-tree-uproot tree 1)
      ;; avoid comparing nodes directly because huge walls of text will be printed
      (assert-false (eq original-root (pmcts-tree-root-node tree)))
      (assert-true (eq expected-root (pmcts-tree-root-node tree)))
      (assert-false (not (not (mcts-node-parent expected-root))))
      (assert-true (null (mcts-node-children original-root))))))
